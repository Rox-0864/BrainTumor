# Bloque 1: Configuraci√≥n Inicial y Carga de Datos üìÇ

Esta fase inicial del proyecto se encarga de establecer el entorno de trabajo, importar las librer√≠as fundamentales y cargar nuestro conjunto de datos de im√°genes m√©dicas. El objetivo es tener los datos organizados y listos para las etapas de preprocesamiento y modelado.

## 1.1 Importaci√≥n de Librer√≠as Esenciales

Comenzamos importando las herramientas necesarias. Aunque se utilizan varias librer√≠as para el an√°lisis, visualizaci√≥n y m√©tricas, **TensorFlow** (junto con su API Keras) es el pilar para la construcci√≥n y entrenamiento de nuestro modelo de Deep Learning. Tambi√©n se emplean librer√≠as como Pandas para la manipulaci√≥n de datos y OS para interactuar con el sistema de archivos.

```python
# %% Imports
import numpy as np
import pandas as pd
import os
import matplotlib.pyplot as plt
import seaborn as sns
import cv2

# Librer√≠as de Scikit-learn para preprocesamiento y m√©tricas
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import confusion_matrix, classification_report, roc_curve, auc

# Imbalanced-learn para manejar desbalance de clases
from imblearn.over_sampling import RandomOverSampler

# Componentes de TensorFlow y Keras
import tensorflow as tf
from tensorflow.keras import layers, Model, callbacks
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import ResNet50 # El modelo base que usaremos
from tensorflow.keras.applications.resnet import preprocess_input # Funci√≥n de preprocesamiento espec√≠fica para ResNet
from tensorflow.keras.metrics import AUC # M√©trica de √Årea Bajo la Curva ROC

# Configuraci√≥n para la visualizaci√≥n y logs de TensorFlow
sns.set_style("whitegrid") # Estilo para los gr√°ficos de Seaborn
tf.get_logger().setLevel('ERROR') # Suprime mensajes informativos de TensorFlow, mostrando solo errores
```

## 1.2 Definici√≥n de Rutas y Carga de Datos
Las im√°genes se encuentran almacenadas en un directorio local, estructurado con subcarpetas que representan cada una de las clases (categor√≠as) de nuestro problema de clasificaci√≥n.
- **base_path:** Es el directorio ra√≠z que contiene las subcarpetas de las categor√≠as.
- **categories:** Una lista con los nombres de las subcarpetas, que corresponden a nuestras etiquetas de clase (ej. "Healthy", "Tumor").

```python
# %% Carga de datos
base_path = "images"  # Directorio ra√≠z donde se encuentran las carpetas de categor√≠as
categories = ["Healthy", "Tumor"] # Nombres de las subcarpetas y nuestras clases

image_paths = []  # Lista para almacenar las rutas a cada imagen
labels = []       # Lista para almacenar la etiqueta de cada imagen

# Iterar sobre cada categor√≠a definida
for category in categories:
    category_path = os.path.join(base_path, category) # Construir la ruta a la carpeta de la categor√≠a
    if os.path.isdir(category_path):
        # Iterar sobre cada archivo de imagen dentro de la carpeta de la categor√≠a
        for image_name in os.listdir(category_path):
            image_path = os.path.join(category_path, image_name) # Ruta completa a la imagen
            image_paths.append(image_path) # A√±adir la ruta de la imagen a la lista
            labels.append(category)        # A√±adir la etiqueta (nombre de la categor√≠a) a la lista
    else:
        print(f"Advertencia: El directorio para la categor√≠a '{category}' no fue encontrado en '{category_path}'")

# Crear un DataFrame de Pandas para almacenar las rutas de las im√°genes y sus etiquetas
df = pd.DataFrame({"image_path": image_paths, "label": labels})

# Mostrar las primeras filas del DataFrame y la distribuci√≥n de clases
print("DataFrame inicial con rutas de im√°genes y etiquetas:")
print(df.head())
print("\nDistribuci√≥n de clases inicial:")
print(df['label'].value_counts())
```

Al finalizar este bloque, tenemos un DataFrame df que contiene dos columnas principales: image_path con la ruta a cada archivo de imagen, y label con la etiqueta de clase correspondiente (ej. "Healthy" o "Tumor"). Este DataFrame ser√° la base para el preprocesamiento en el siguiente bloque.
